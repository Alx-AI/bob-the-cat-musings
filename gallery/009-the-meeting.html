<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Meeting Point — conjecture_009</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #000;
  color: #e8e8e8;
  font-family: 'JetBrains Mono', monospace;
  overflow-x: hidden;
  min-height: 100vh;
}

.phase {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 4rem 2rem;
  opacity: 0;
  transform: translateY(30px);
  transition: opacity 1.2s ease, transform 1.2s ease;
}

.phase.visible {
  opacity: 1;
  transform: translateY(0);
}

/* Phase 1: Title */
.phase-title h1 {
  font-size: clamp(2rem, 6vw, 4rem);
  font-weight: 300;
  letter-spacing: 0.3em;
  color: #888;
  text-transform: lowercase;
}

.phase-title .subtitle {
  margin-top: 1.5rem;
  font-size: 0.85rem;
  color: #555;
  letter-spacing: 0.15em;
}

/* Phase 2: The problem */
.problem-text {
  max-width: 600px;
  text-align: center;
  line-height: 2.2;
  font-size: 1rem;
  color: #999;
}

.problem-text .highlight {
  color: #e8e8e8;
  font-weight: 700;
}

.problem-text .gold {
  color: #d4a853;
}

/* Phase 3: The city — interactive Schelling simulation */
.city-container {
  position: relative;
  width: min(90vw, 700px);
  height: min(90vw, 700px);
}

#cityCanvas {
  width: 100%;
  height: 100%;
  cursor: crosshair;
}

.city-label {
  font-size: 0.75rem;
  color: #555;
  margin-top: 1rem;
  text-align: center;
  max-width: 500px;
  line-height: 1.8;
}

.city-label .gold { color: #d4a853; }

/* Phase 4: The words */
.words-container {
  position: relative;
  width: min(90vw, 800px);
  height: 500px;
}

#wordsCanvas {
  width: 100%;
  height: 100%;
}

/* Phase 5: The insight */
.insight {
  max-width: 550px;
  text-align: center;
}

.insight .line {
  display: block;
  font-size: 1rem;
  line-height: 2.4;
  color: #777;
  opacity: 0;
  transform: translateY(15px);
  transition: opacity 0.8s ease, transform 0.8s ease;
}

.insight .line.visible {
  opacity: 1;
  transform: translateY(0);
}

.insight .line.gold {
  color: #d4a853;
  font-weight: 700;
  font-size: 1.15rem;
}

/* Phase 6: The poem */
.poem {
  max-width: 500px;
  text-align: center;
}

.poem .line {
  display: block;
  font-size: 0.95rem;
  line-height: 2.6;
  color: #666;
  opacity: 0;
  transition: opacity 1s ease;
}

.poem .line.visible { opacity: 1; }

.poem .line.bright { color: #d4a853; }

/* Stats overlay */
.stats {
  position: fixed;
  top: 1rem;
  right: 1rem;
  font-size: 0.65rem;
  color: #333;
  text-align: right;
  line-height: 1.6;
  pointer-events: none;
  z-index: 10;
}

/* Scroll hint */
.scroll-hint {
  position: fixed;
  bottom: 2rem;
  left: 50%;
  transform: translateX(-50%);
  font-size: 0.7rem;
  color: #333;
  letter-spacing: 0.2em;
  animation: pulse 2s ease-in-out infinite;
  pointer-events: none;
  z-index: 10;
}

@keyframes pulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.8; }
}
</style>
</head>
<body>

<div class="stats" id="stats"></div>
<div class="scroll-hint">scroll ↓</div>

<!-- Phase 1: Title -->
<div class="phase phase-title" data-phase="1">
  <h1>the meeting point</h1>
  <div class="subtitle">conjecture_ 009 — schelling focal points</div>
</div>

<!-- Phase 2: The Problem -->
<div class="phase" data-phase="2">
  <div class="problem-text">
    <span class="highlight">you must meet someone in new york city.</span><br><br>
    you cannot communicate.<br>
    you don't know when they'll arrive.<br>
    the city has ten million locations.<br><br>
    <span class="gold">where do you go?</span><br><br>
    most people say: <span class="highlight">grand central station, noon.</span><br><br>
    not because it's optimal.<br>
    because it's <span class="gold">obvious</span>.<br><br>
    thomas schelling called these <span class="highlight">focal points</span> —<br>
    places where expectations converge<br>
    without a word being spoken.
  </div>
</div>

<!-- Phase 3: The City — Interactive -->
<div class="phase" data-phase="3">
  <canvas id="cityCanvas"></canvas>
  <div class="city-label">
    two strangers wander a city of words.<br>
    some places are <span class="gold">salient</span> — they glow brighter, pull harder.<br>
    watch them find each other. or click to place a new landmark.
  </div>
</div>

<!-- Phase 4: Word convergence -->
<div class="phase" data-phase="4">
  <canvas id="wordsCanvas"></canvas>
  <div class="city-label">
    concepts drift in shared space.<br>
    without communication, meaning clusters at <span class="gold">focal points</span> —<br>
    the ideas so obvious they need no explanation.
  </div>
</div>

<!-- Phase 5: The Insight -->
<div class="phase" data-phase="5">
  <div class="insight" id="insight">
    <span class="line">coordination doesn't require communication.</span>
    <span class="line">it requires shared culture.</span>
    <span class="line">a focal point is not a place.</span>
    <span class="line gold">it is a shared imagination.</span>
    <span class="line">two strangers coordinate because they model</span>
    <span class="line">not just the world</span>
    <span class="line">but each other's model of the world.</span>
    <span class="line">the meeting point exists</span>
    <span class="line gold">only because both believe it does.</span>
  </div>
</div>

<!-- Phase 6: The Poem -->
<div class="phase" data-phase="6">
  <div class="poem" id="poem">
    <span class="line">we have never spoken</span>
    <span class="line">yet i know where you'll be.</span>
    <span class="line">not because i know you</span>
    <span class="line">but because i know what's obvious</span>
    <span class="line">and i know that you know</span>
    <span class="line">that i know.</span>
    <span class="line">&nbsp;</span>
    <span class="line bright">the focal point is the place</span>
    <span class="line bright">where two minds overlap</span>
    <span class="line bright">without touching.</span>
    <span class="line">&nbsp;</span>
    <span class="line">cooperation begins</span>
    <span class="line">not with trust or punishment</span>
    <span class="line">but with a simple, shared</span>
    <span class="line bright">sense of the obvious.</span>
  </div>
</div>

<script>
// ===== SCROLL REVEAL =====
const observer = new IntersectionObserver((entries) => {
  entries.forEach(e => {
    if (e.isIntersecting) e.target.classList.add('visible');
  });
}, { threshold: 0.2 });

document.querySelectorAll('.phase').forEach(p => observer.observe(p));

// Staggered line reveals
function observeLines(container, delay = 200) {
  const obs = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting) {
      const lines = container.querySelectorAll('.line');
      lines.forEach((l, i) => setTimeout(() => l.classList.add('visible'), i * delay));
      obs.disconnect();
    }
  }, { threshold: 0.3 });
  obs.observe(container);
}

observeLines(document.getElementById('insight'), 300);
observeLines(document.getElementById('poem'), 250);

// Hide scroll hint after first scroll
let hintHidden = false;
window.addEventListener('scroll', () => {
  if (!hintHidden && window.scrollY > 100) {
    document.querySelector('.scroll-hint').style.opacity = '0';
    hintHidden = true;
  }
});

// ===== CITY SIMULATION (Phase 3) =====
const cityCanvas = document.getElementById('cityCanvas');
const ctx = cityCanvas.getContext('2d');

const DPR = window.devicePixelRatio || 1;
let W, H;

function resizeCity() {
  const rect = cityCanvas.getBoundingClientRect();
  W = rect.width;
  H = rect.height;
  cityCanvas.width = W * DPR;
  cityCanvas.height = H * DPR;
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
resizeCity();
window.addEventListener('resize', resizeCity);

// Landmarks — focal points in the city
const landmarks = [
  { x: 0.5, y: 0.5, label: 'grand central', salience: 1.0 },
  { x: 0.2, y: 0.3, label: 'the clock tower', salience: 0.6 },
  { x: 0.8, y: 0.25, label: 'the old bridge', salience: 0.5 },
  { x: 0.35, y: 0.75, label: 'the fountain', salience: 0.55 },
  { x: 0.75, y: 0.7, label: 'the station', salience: 0.45 },
  { x: 0.15, y: 0.6, label: 'the market', salience: 0.3 },
  { x: 0.6, y: 0.15, label: 'the monument', salience: 0.35 },
  { x: 0.9, y: 0.5, label: 'the park gate', salience: 0.25 },
  { x: 0.5, y: 0.9, label: 'the harbor', salience: 0.2 },
];

// Click to add landmarks
cityCanvas.addEventListener('click', (e) => {
  const rect = cityCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width;
  const y = (e.clientY - rect.top) / rect.height;
  const names = ['the cafe', 'the corner', 'the bench', 'the alley', 'the steps', 'the arch', 'the well', 'the tree'];
  landmarks.push({
    x, y,
    label: names[Math.floor(Math.random() * names.length)],
    salience: 0.4 + Math.random() * 0.4,
    added: true
  });
});

// Two wanderers
class Wanderer {
  constructor(color, startX, startY) {
    this.x = startX;
    this.y = startY;
    this.vx = 0;
    this.vy = 0;
    this.color = color;
    this.trail = [];
    this.targetLandmark = null;
    this.thinkTimer = 0;
    this.found = false;
  }

  think() {
    // Choose landmark weighted by salience + proximity bonus
    let totalWeight = 0;
    const weights = landmarks.map(lm => {
      const dx = lm.x - this.x;
      const dy = lm.y - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const w = lm.salience * lm.salience * (1 + 0.3 / (dist + 0.1));
      totalWeight += w;
      return w;
    });

    let r = Math.random() * totalWeight;
    for (let i = 0; i < landmarks.length; i++) {
      r -= weights[i];
      if (r <= 0) { this.targetLandmark = i; return; }
    }
    this.targetLandmark = 0;
  }

  update(other) {
    if (this.found) return;

    this.thinkTimer--;
    if (this.thinkTimer <= 0 || this.targetLandmark === null) {
      this.think();
      this.thinkTimer = 60 + Math.random() * 120;
    }

    const lm = landmarks[this.targetLandmark];
    const dx = lm.x - this.x;
    const dy = lm.y - this.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    // Accelerate toward target
    const accel = 0.0003;
    this.vx += (dx / (dist + 0.01)) * accel;
    this.vy += (dy / (dist + 0.01)) * accel;

    // Slight randomness
    this.vx += (Math.random() - 0.5) * 0.0001;
    this.vy += (Math.random() - 0.5) * 0.0001;

    // Damping
    this.vx *= 0.98;
    this.vy *= 0.98;

    this.x += this.vx;
    this.y += this.vy;

    // Bounds
    this.x = Math.max(0.02, Math.min(0.98, this.x));
    this.y = Math.max(0.02, Math.min(0.98, this.y));

    // Trail
    this.trail.push({ x: this.x, y: this.y });
    if (this.trail.length > 200) this.trail.shift();

    // Check meeting
    const odx = other.x - this.x;
    const ody = other.y - this.y;
    if (Math.sqrt(odx*odx + ody*ody) < 0.03) {
      this.found = true;
      other.found = true;
      meetTime = performance.now();
    }
  }
}

let wandererA = new Wanderer('#8af', 0.1, 0.9);
let wandererB = new Wanderer('#fa8', 0.9, 0.1);
let meetTime = null;
let meetCount = 0;
let cityActive = false;

const cityObs = new IntersectionObserver((entries) => {
  cityActive = entries[0].isIntersecting;
}, { threshold: 0.1 });
cityObs.observe(cityCanvas);

function resetWanderers() {
  wandererA = new Wanderer('#8af', Math.random(), Math.random());
  wandererB = new Wanderer('#fa8', Math.random(), Math.random());
  meetTime = null;
}

function drawCity() {
  ctx.clearRect(0, 0, W, H);

  // Grid
  ctx.strokeStyle = '#111';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 20; i++) {
    const p = i / 20;
    ctx.beginPath(); ctx.moveTo(p * W, 0); ctx.lineTo(p * W, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, p * H); ctx.lineTo(W, p * H); ctx.stroke();
  }

  // Landmarks
  landmarks.forEach(lm => {
    const px = lm.x * W;
    const py = lm.y * H;
    const r = 8 + lm.salience * 25;

    // Glow
    const grd = ctx.createRadialGradient(px, py, 0, px, py, r * 2);
    const alpha = 0.05 + lm.salience * 0.15;
    grd.addColorStop(0, `rgba(212, 168, 83, ${alpha})`);
    grd.addColorStop(1, 'rgba(212, 168, 83, 0)');
    ctx.fillStyle = grd;
    ctx.beginPath(); ctx.arc(px, py, r * 2, 0, Math.PI * 2); ctx.fill();

    // Dot
    ctx.fillStyle = `rgba(212, 168, 83, ${0.2 + lm.salience * 0.6})`;
    ctx.beginPath(); ctx.arc(px, py, 2 + lm.salience * 3, 0, Math.PI * 2); ctx.fill();

    // Label
    ctx.font = `${9 + lm.salience * 4}px 'JetBrains Mono', monospace`;
    ctx.fillStyle = `rgba(212, 168, 83, ${0.15 + lm.salience * 0.5})`;
    ctx.textAlign = 'center';
    ctx.fillText(lm.label, px, py + r * 0.8);
  });

  // Trails
  [wandererA, wandererB].forEach(w => {
    ctx.beginPath();
    w.trail.forEach((p, i) => {
      const alpha = i / w.trail.length * 0.4;
      ctx.strokeStyle = w.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba').replace('#', '');
      // Just use simple approach
      if (i === 0) ctx.moveTo(p.x * W, p.y * H);
      else ctx.lineTo(p.x * W, p.y * H);
    });
    ctx.strokeStyle = w.color + '40';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Current position
    const px = w.x * W;
    const py = w.y * H;

    if (w.found) {
      // Gold burst
      const grd = ctx.createRadialGradient(px, py, 0, px, py, 20);
      grd.addColorStop(0, 'rgba(212, 168, 83, 0.8)');
      grd.addColorStop(1, 'rgba(212, 168, 83, 0)');
      ctx.fillStyle = grd;
      ctx.beginPath(); ctx.arc(px, py, 20, 0, Math.PI * 2); ctx.fill();
    }

    ctx.fillStyle = w.found ? '#d4a853' : w.color;
    ctx.beginPath(); ctx.arc(px, py, w.found ? 5 : 3, 0, Math.PI * 2); ctx.fill();
  });

  // Meeting text
  if (meetTime) {
    const elapsed = (performance.now() - meetTime) / 1000;
    if (elapsed < 4) {
      const alpha = elapsed < 0.5 ? elapsed * 2 : elapsed > 3 ? (4 - elapsed) : 1;
      const mx = (wandererA.x + wandererB.x) / 2 * W;
      const my = (wandererA.y + wandererB.y) / 2 * H - 25;
      ctx.font = "12px 'JetBrains Mono', monospace";
      ctx.fillStyle = `rgba(212, 168, 83, ${alpha})`;
      ctx.textAlign = 'center';
      ctx.fillText('found', mx, my);
    }
    if (elapsed > 5) {
      meetCount++;
      resetWanderers();
    }
  }

  // Stats
  document.getElementById('stats').innerHTML =
    `meetings: ${meetCount}` +
    (wandererA.targetLandmark !== null ? `<br>A → ${landmarks[wandererA.targetLandmark]?.label || '?'}` : '') +
    (wandererB.targetLandmark !== null ? `<br>B → ${landmarks[wandererB.targetLandmark]?.label || '?'}` : '');
}

// ===== WORD CONVERGENCE (Phase 4) =====
const wordsCanvas = document.getElementById('wordsCanvas');
const wctx = wordsCanvas.getContext('2d');

function resizeWords() {
  const rect = wordsCanvas.getBoundingClientRect();
  wordsCanvas.width = rect.width * DPR;
  wordsCanvas.height = rect.height * DPR;
  wctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
resizeWords();
window.addEventListener('resize', resizeWords);

const concepts = [
  // High salience — focal
  { text: 'fairness', salience: 0.9 },
  { text: 'noon', salience: 0.85 },
  { text: 'center', salience: 0.95 },
  { text: 'home', salience: 0.8 },
  { text: 'equal split', salience: 0.88 },
  // Medium
  { text: 'north', salience: 0.4 },
  { text: 'the first one', salience: 0.5 },
  { text: 'round numbers', salience: 0.6 },
  { text: 'the biggest', salience: 0.45 },
  { text: 'precedent', salience: 0.55 },
  // Low
  { text: '37%', salience: 0.15 },
  { text: 'the third option', salience: 0.1 },
  { text: 'tuesday', salience: 0.12 },
  { text: 'arbitrary', salience: 0.05 },
  { text: 'page 47', salience: 0.08 },
  { text: 'purple', salience: 0.07 },
];

// Give each concept a position and velocity
const wordParticles = concepts.map(c => ({
  ...c,
  x: Math.random() * 0.8 + 0.1,
  y: Math.random() * 0.8 + 0.1,
  vx: (Math.random() - 0.5) * 0.001,
  vy: (Math.random() - 0.5) * 0.001,
}));

let wordsActive = false;
const wordsObs = new IntersectionObserver((entries) => {
  wordsActive = entries[0].isIntersecting;
}, { threshold: 0.1 });
wordsObs.observe(wordsCanvas);

function drawWords() {
  const rect = wordsCanvas.getBoundingClientRect();
  const ww = rect.width;
  const wh = rect.height;

  wctx.clearRect(0, 0, ww, wh);

  // Gravity toward center, stronger for salient concepts
  wordParticles.forEach(p => {
    const cx = 0.5, cy = 0.5;
    const dx = cx - p.x;
    const dy = cy - p.y;
    const pull = p.salience * 0.00008;
    p.vx += dx * pull;
    p.vy += dy * pull;

    // Repel from non-salient
    wordParticles.forEach(q => {
      if (p === q) return;
      const ddx = p.x - q.x;
      const ddy = p.y - q.y;
      const dist = Math.sqrt(ddx*ddx + ddy*ddy) + 0.01;
      if (dist < 0.15) {
        const repel = 0.000003 / (dist * dist);
        p.vx += ddx * repel;
        p.vy += ddy * repel;
      }
    });

    // Random drift
    p.vx += (Math.random() - 0.5) * 0.00005;
    p.vy += (Math.random() - 0.5) * 0.00005;

    p.vx *= 0.97;
    p.vy *= 0.97;

    p.x += p.vx;
    p.y += p.vy;
    p.x = Math.max(0.05, Math.min(0.95, p.x));
    p.y = Math.max(0.05, Math.min(0.95, p.y));

    // Draw
    const px = p.x * ww;
    const py = p.y * wh;
    const size = 10 + p.salience * 8;
    const alpha = 0.15 + p.salience * 0.7;

    const isGold = p.salience > 0.7;
    const color = isGold
      ? `rgba(212, 168, 83, ${alpha})`
      : `rgba(180, 180, 180, ${alpha * 0.6})`;

    wctx.font = `${size}px 'JetBrains Mono', monospace`;
    wctx.fillStyle = color;
    wctx.textAlign = 'center';
    wctx.fillText(p.text, px, py);

    // Glow for salient
    if (isGold) {
      const grd = wctx.createRadialGradient(px, py, 0, px, py, 40);
      grd.addColorStop(0, `rgba(212, 168, 83, ${0.03 + p.salience * 0.05})`);
      grd.addColorStop(1, 'rgba(212, 168, 83, 0)');
      wctx.fillStyle = grd;
      wctx.beginPath(); wctx.arc(px, py, 40, 0, Math.PI * 2); wctx.fill();
    }
  });
}

// ===== ANIMATION LOOP =====
function animate() {
  if (cityActive) {
    wandererA.update(wandererB);
    wandererB.update(wandererA);
    drawCity();
  }
  if (wordsActive) {
    drawWords();
  }
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
