<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>the tournament — conjecture_</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    color: #ddd;
    font-family: 'JetBrains Mono', monospace;
    overflow-x: hidden;
    min-height: 100vh;
  }

  canvas#bg {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
    pointer-events: none;
  }

  .content {
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8vh 5vw 20vh;
  }

  .phase {
    opacity: 0;
    transform: translateY(40px);
    transition: opacity 1.4s ease, transform 1.4s ease;
    margin-bottom: 14vh;
    width: 100%;
    max-width: 860px;
    text-align: center;
  }
  .phase.visible {
    opacity: 1;
    transform: translateY(0);
  }

  h1 {
    font-size: clamp(2.2rem, 5vw, 4rem);
    font-weight: 300;
    letter-spacing: 0.35em;
    color: #777;
    margin-bottom: 1rem;
  }
  .subtitle {
    font-size: 0.85rem;
    color: #555;
    letter-spacing: 0.15em;
  }

  /* Strategy cards */
  .arena {
    display: flex;
    flex-direction: column;
    gap: 0;
    width: 100%;
  }

  .match {
    display: flex;
    width: 100%;
    gap: 0;
    margin-bottom: 2px;
  }

  .strategy-col {
    flex: 1;
    padding: 2rem 1.5rem;
    position: relative;
    min-height: 180px;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
  .strategy-col.left {
    text-align: right;
    border-right: 1px solid #222;
  }
  .strategy-col.right {
    text-align: left;
    border-left: 1px solid #222;
  }

  .strat-name {
    font-size: 1rem;
    font-weight: 500;
    letter-spacing: 0.2em;
    margin-bottom: 0.8rem;
    text-transform: uppercase;
  }

  .monologue {
    font-size: 0.72rem;
    line-height: 1.9;
    color: #666;
    font-weight: 300;
  }
  .monologue .thought {
    display: block;
    opacity: 0;
    transition: opacity 0.8s ease;
  }
  .monologue .thought.show {
    opacity: 1;
  }

  /* Score bar */
  .score-bar {
    width: 100%;
    height: 3px;
    background: #111;
    margin: 0.5rem 0;
    position: relative;
    overflow: hidden;
  }
  .score-fill {
    height: 100%;
    background: #c8a84e;
    width: 0%;
    transition: width 0.6s ease;
  }
  .score-fill.losing {
    background: #664433;
  }

  /* The round-by-round */
  .rounds-display {
    font-size: 0.6rem;
    letter-spacing: 0.3em;
    color: #444;
    margin-top: 0.5rem;
    font-family: 'JetBrains Mono', monospace;
    word-break: break-all;
  }
  .rounds-display .c { color: #6a9f6a; }
  .rounds-display .d { color: #9f4444; }

  /* Center divider */
  .vs {
    width: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #333;
    font-size: 0.65rem;
    letter-spacing: 0.1em;
  }

  /* Leaderboard */
  .leaderboard {
    width: 100%;
    max-width: 600px;
  }
  .leader-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 0.6rem;
    opacity: 0;
    transform: translateX(-20px);
    transition: all 0.8s ease;
  }
  .leader-row.show {
    opacity: 1;
    transform: translateX(0);
  }
  .leader-rank {
    font-size: 0.7rem;
    color: #555;
    width: 2rem;
    text-align: right;
  }
  .leader-name {
    font-size: 0.8rem;
    letter-spacing: 0.15em;
    width: 160px;
  }
  .leader-bar-wrap {
    flex: 1;
    height: 4px;
    background: #111;
    position: relative;
  }
  .leader-bar {
    height: 100%;
    transition: width 1.5s ease;
    width: 0;
  }
  .leader-score {
    font-size: 0.65rem;
    color: #666;
    width: 3rem;
    text-align: right;
  }

  /* Poem */
  .poem {
    font-size: clamp(0.8rem, 1.8vw, 1rem);
    line-height: 2.2;
    color: #999;
    font-weight: 300;
    max-width: 560px;
    margin: 0 auto;
  }
  .poem .gold { color: #c8a84e; }
  .poem .dim { color: #555; }

  /* Calligram */
  .calligram-container {
    position: relative;
    width: 100%;
    max-width: 700px;
    margin: 0 auto;
  }
  #calligram-canvas {
    width: 100%;
    height: auto;
  }

  .closing {
    font-size: 0.7rem;
    color: #444;
    letter-spacing: 0.2em;
    margin-top: 8vh;
  }
</style>
</head>
<body>

<canvas id="bg"></canvas>

<div class="content">

  <!-- Phase 1: Title -->
  <div class="phase" data-phase="1">
    <h1>the tournament</h1>
    <div class="subtitle">axelrod, 1980 — what wins?</div>
  </div>

  <!-- Phase 2: The Setup -->
  <div class="phase" data-phase="2">
    <div style="font-size: 0.8rem; line-height: 2.4; color: #888; max-width: 580px; margin: 0 auto; text-align: left;">
      <p>in 1980, robert axelrod invited game theorists,<br>
      economists, mathematicians, and computer scientists<br>
      to submit strategies for an iterated prisoner's dilemma.</p>
      <p style="margin-top: 1.5rem; color: #666;">
      each strategy would play every other strategy.<br>
      200 rounds each. points for mutual cooperation,<br>
      punishment for mutual defection,<br>
      temptation for betrayal, and the sucker's payoff for trust.</p>
      <p style="margin-top: 1.5rem; color: #555;">
      fourteen strategies entered.<br>
      what follows are five of them,<br>
      speaking in their own voices.</p>
    </div>
  </div>

  <!-- Phase 3: Strategy introductions as inner monologues -->
  <div class="phase" data-phase="3">
    <div class="arena" id="introductions">
      <!-- Generated by JS -->
    </div>
  </div>

  <!-- Phase 4: The matches (animated round-by-round) -->
  <div class="phase" data-phase="4">
    <div style="font-size: 0.75rem; color: #555; letter-spacing: 0.2em; margin-bottom: 3rem;">
      ROUND BY ROUND
    </div>
    <div class="arena" id="matches">
      <!-- Generated by JS -->
    </div>
  </div>

  <!-- Phase 5: Leaderboard reveal -->
  <div class="phase" data-phase="5">
    <div style="font-size: 0.75rem; color: #555; letter-spacing: 0.2em; margin-bottom: 3rem;">
      FINAL STANDINGS
    </div>
    <div class="leaderboard" id="leaderboard">
      <!-- Generated by JS -->
    </div>
  </div>

  <!-- Phase 6: The calligram — TIT FOR TAT spelled in its own description -->
  <div class="phase" data-phase="6">
    <div class="calligram-container">
      <canvas id="calligram-canvas" width="700" height="500"></canvas>
    </div>
  </div>

  <!-- Phase 7: The lesson -->
  <div class="phase" data-phase="7">
    <div class="poem">
      <span class="dim">the simplest strategy won.</span><br><br>
      not the cleverest.<br>
      not the most aggressive.<br>
      not the one with the deepest model of its opponent.<br><br>
      <span class="gold">four lines of code:</span><br>
      cooperate first.<br>
      then do what they did.<br><br>
      <span class="dim">it never once beat anyone.</span><br>
      <span class="dim">it never scored higher than its partner in any single match.</span><br><br>
      and yet —<br><br>
      <span class="gold">it won the tournament.</span><br><br>
      because winning isn't about beating the person in front of you.<br>
      it's about what happens across<br>
      <span class="gold">every interaction you'll ever have.</span><br><br>
      <span class="dim">nice. retaliatory. forgiving. clear.</span><br><br>
      be good first.<br>
      punish betrayal.<br>
      forgive immediately.<br>
      be legible.<br><br>
      <span class="gold">the meek inherit the iterated game.</span>
    </div>
  </div>

  <div class="phase" data-phase="8">
    <div class="closing">conjecture_ — 010</div>
  </div>

</div>

<script>
// === STRATEGIES ===
const strategies = [
  {
    name: 'TIT FOR TAT',
    color: '#c8a84e',
    voice: [
      'i start by trusting you.',
      'then i become your mirror.',
      'you cooperate — i cooperate.',
      'you betray — i betray.',
      'i hold no grudges.',
      'i have no memory beyond yesterday.',
      'i am four lines of code.',
      'i am the simplest thing here.',
    ],
    fn: (myHist, theirHist) => theirHist.length === 0 ? 'C' : theirHist[theirHist.length - 1]
  },
  {
    name: 'ALWAYS DEFECT',
    color: '#9f4444',
    voice: [
      'i take.',
      'every time.',
      'you cooperate — i take more.',
      'you defect — at least i\'m not the sucker.',
      'trust is a resource to be exploited.',
      'the strong do what they can.',
      'the weak suffer what they must.',
      'i will never go first.',
    ],
    fn: () => 'D'
  },
  {
    name: 'ALWAYS COOPERATE',
    color: '#6a9f6a',
    voice: [
      'i give.',
      'every time.',
      'you betray me — i give again.',
      'i believe in the best version of you.',
      'i cannot be provoked.',
      'i cannot learn.',
      'i am kindness without teeth.',
      'i will be devoured.',
    ],
    fn: () => 'C'
  },
  {
    name: 'GRUDGER',
    color: '#7a7aaf',
    voice: [
      'i cooperate until you don\'t.',
      'one betrayal. that\'s all it takes.',
      'i will cooperate with you forever.',
      'but the moment you defect —',
      'i defect forever.',
      'i never forgive.',
      'i never forget.',
      'my memory is a prison for both of us.',
    ],
    fn: (myHist, theirHist) => theirHist.includes('D') ? 'D' : 'C'
  },
  {
    name: 'RANDOM',
    color: '#888',
    voice: [
      'i flip a coin.',
      'i have no strategy.',
      'i have no memory.',
      'i have no purpose.',
      'i am noise.',
      'i am the thing that breaks patterns.',
      'cooperate, defect — what\'s the difference?',
      'i am entropy.',
    ],
    fn: () => Math.random() < 0.5 ? 'C' : 'D'
  }
];

// === GAME ENGINE ===
function playMatch(a, b, rounds = 200) {
  let aHist = [], bHist = [];
  let aScore = 0, bScore = 0;
  const history = [];

  for (let r = 0; r < rounds; r++) {
    const aMove = a.fn([...aHist], [...bHist]);
    const bMove = b.fn([...bHist], [...aHist]);
    aHist.push(aMove);
    bHist.push(bMove);

    if (aMove === 'C' && bMove === 'C') { aScore += 3; bScore += 3; }
    else if (aMove === 'C' && bMove === 'D') { aScore += 0; bScore += 5; }
    else if (aMove === 'D' && bMove === 'C') { aScore += 5; bScore += 0; }
    else { aScore += 1; bScore += 1; }

    history.push([aMove, bMove]);
  }
  return { aScore, bScore, history, aHist, bHist };
}

// Run all matches
const matchResults = [];
const totalScores = {};
strategies.forEach(s => totalScores[s.name] = 0);

for (let i = 0; i < strategies.length; i++) {
  for (let j = i + 1; j < strategies.length; j++) {
    const result = playMatch(strategies[i], strategies[j]);
    matchResults.push({
      a: strategies[i],
      b: strategies[j],
      ...result
    });
    totalScores[strategies[i].name] += result.aScore;
    totalScores[strategies[j].name] += result.bScore;
  }
}

// === RENDER INTRODUCTIONS ===
const introDiv = document.getElementById('introductions');
strategies.forEach((s, i) => {
  const card = document.createElement('div');
  card.style.cssText = `margin-bottom: 3rem; text-align: left; padding-left: 1.5rem; border-left: 2px solid ${s.color}33;`;
  card.innerHTML = `
    <div class="strat-name" style="color: ${s.color}; text-align: left;">${s.name}</div>
    <div class="monologue" id="intro-mono-${i}">
      ${s.voice.map((t, j) => `<span class="thought" data-delay="${j * 400}">${t}</span>`).join('')}
    </div>
  `;
  introDiv.appendChild(card);
});

// === RENDER MATCHES (select 5 key matchups) ===
const keyMatchups = [
  ['TIT FOR TAT', 'ALWAYS DEFECT'],
  ['TIT FOR TAT', 'ALWAYS COOPERATE'],
  ['ALWAYS DEFECT', 'ALWAYS COOPERATE'],
  ['TIT FOR TAT', 'GRUDGER'],
  ['ALWAYS DEFECT', 'RANDOM'],
];

const matchesDiv = document.getElementById('matches');
keyMatchups.forEach((pair, idx) => {
  const mr = matchResults.find(m =>
    (m.a.name === pair[0] && m.b.name === pair[1]) ||
    (m.a.name === pair[1] && m.b.name === pair[0])
  );
  if (!mr) return;

  const swapped = mr.a.name !== pair[0];
  const left = swapped ? mr.b : mr.a;
  const right = swapped ? mr.a : mr.b;
  const leftScore = swapped ? mr.bScore : mr.aScore;
  const rightScore = swapped ? mr.aScore : mr.bScore;
  const hist = mr.history.map(h => swapped ? [h[1], h[0]] : h);

  const maxScore = Math.max(leftScore, rightScore);

  const matchEl = document.createElement('div');
  matchEl.className = 'match';
  matchEl.style.marginBottom = '3rem';
  matchEl.innerHTML = `
    <div class="strategy-col left">
      <div class="strat-name" style="color: ${left.color}">${left.name}</div>
      <div class="score-bar"><div class="score-fill ${leftScore < rightScore ? 'losing' : ''}" id="score-l-${idx}" style="width:0%"></div></div>
      <div style="font-size:0.65rem;color:#555;margin-top:0.3rem" id="pts-l-${idx}">0</div>
    </div>
    <div class="vs">vs</div>
    <div class="strategy-col right">
      <div class="strat-name" style="color: ${right.color}">${right.name}</div>
      <div class="score-bar"><div class="score-fill ${rightScore < leftScore ? 'losing' : ''}" id="score-r-${idx}" style="width:0%"></div></div>
      <div style="font-size:0.65rem;color:#555;margin-top:0.3rem" id="pts-r-${idx}">0</div>
    </div>
  `;

  // Round display (show first 40 rounds as colored letters)
  const roundsEl = document.createElement('div');
  roundsEl.className = 'rounds-display';
  roundsEl.id = `rounds-${idx}`;
  roundsEl.style.cssText = 'margin-top: 0.5rem; text-align: center;';
  matchEl.appendChild(roundsEl);

  matchesDiv.appendChild(matchEl);

  // Store data for animation
  matchEl.dataset.leftScore = leftScore;
  matchEl.dataset.rightScore = rightScore;
  matchEl.dataset.maxScore = maxScore;
  matchEl.dataset.hist = JSON.stringify(hist.slice(0, 40));
  matchEl.dataset.idx = idx;
});

// === RENDER LEADERBOARD ===
const sorted = Object.entries(totalScores).sort((a, b) => b[1] - a[1]);
const maxTotal = sorted[0][1];
const lbDiv = document.getElementById('leaderboard');

sorted.forEach(([name, score], i) => {
  const s = strategies.find(st => st.name === name);
  const row = document.createElement('div');
  row.className = 'leader-row';
  row.id = `leader-${i}`;
  row.innerHTML = `
    <div class="leader-rank">${i + 1}.</div>
    <div class="leader-name" style="color: ${s.color}">${name}</div>
    <div class="leader-bar-wrap">
      <div class="leader-bar" id="lb-bar-${i}" style="background: ${s.color}; width: 0%"></div>
    </div>
    <div class="leader-score" id="lb-score-${i}">0</div>
  `;
  lbDiv.appendChild(row);
});

// === CALLIGRAM: TIT FOR TAT in block letters made of its description ===
const calCanvas = document.getElementById('calligram-canvas');
const calCtx = calCanvas.getContext('2d');

function drawCalligram() {
  const W = 700, H = 500;
  calCanvas.width = W;
  calCanvas.height = H;
  calCtx.fillStyle = '#000';
  calCtx.fillRect(0, 0, W, H);

  // Draw "TFT" in large letters
  calCtx.font = 'bold 280px JetBrains Mono, monospace';
  calCtx.textAlign = 'center';
  calCtx.textBaseline = 'middle';
  calCtx.fillStyle = '#fff';
  calCtx.fillText('TFT', W/2, H/2);

  // Get image data to use as mask
  const imgData = calCtx.getImageData(0, 0, W, H);

  // Clear and redraw with small text
  calCtx.fillStyle = '#000';
  calCtx.fillRect(0, 0, W, H);

  const phrases = [
    'cooperate first', 'then mirror', 'nice', 'retaliatory', 'forgiving', 'clear',
    'i start with trust', 'you betray i betray', 'you give i give', 'no grudges',
    'four lines of code', 'the simplest wins', 'be good first', 'punish once',
    'forgive immediately', 'be legible', 'never beat anyone', 'won everything',
    'reciprocity', 'clarity', 'kindness with teeth', 'the mirror strategy',
  ];

  calCtx.font = '7px JetBrains Mono, monospace';
  calCtx.textAlign = 'left';

  let phraseIdx = 0;
  let y = 8;
  while (y < H) {
    let x = 4;
    while (x < W - 4) {
      const px = Math.floor(x);
      const py = Math.floor(y);
      if (px >= 0 && px < W && py >= 0 && py < H) {
        const idx = (py * W + px) * 4;
        const brightness = imgData.data[idx]; // R channel
        if (brightness > 128) {
          const phrase = phrases[phraseIdx % phrases.length];
          phraseIdx++;
          calCtx.fillStyle = `rgba(200, 168, 78, ${0.4 + Math.random() * 0.5})`;
          calCtx.fillText(phrase, x, y);
          x += calCtx.measureText(phrase).width + 6;
        } else {
          x += 8;
        }
      } else {
        x += 8;
      }
    }
    y += 10;
  }
}

// === BACKGROUND CANVAS ===
const bg = document.getElementById('bg');
const bgCtx = bg.getContext('2d');
let particles = [];

function resizeBg() {
  bg.width = window.innerWidth;
  bg.height = window.innerHeight;
}
resizeBg();
window.addEventListener('resize', resizeBg);

// Create particles representing cooperate/defect moves
for (let i = 0; i < 60; i++) {
  particles.push({
    x: Math.random() * window.innerWidth,
    y: Math.random() * window.innerHeight,
    vx: (Math.random() - 0.5) * 0.3,
    vy: (Math.random() - 0.5) * 0.3,
    type: Math.random() < 0.6 ? 'C' : 'D',
    size: 8 + Math.random() * 4,
    alpha: 0.08 + Math.random() * 0.07,
  });
}

function animBg() {
  bgCtx.fillStyle = 'rgba(0,0,0,0.15)';
  bgCtx.fillRect(0, 0, bg.width, bg.height);

  particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    if (p.x < 0) p.x = bg.width;
    if (p.x > bg.width) p.x = 0;
    if (p.y < 0) p.y = bg.height;
    if (p.y > bg.height) p.y = 0;

    bgCtx.font = `${p.size}px JetBrains Mono`;
    bgCtx.fillStyle = p.type === 'C'
      ? `rgba(106,159,106,${p.alpha})`
      : `rgba(159,68,68,${p.alpha})`;
    bgCtx.fillText(p.type, p.x, p.y);
  });

  // Draw faint connections between nearby same-type particles
  for (let i = 0; i < particles.length; i++) {
    for (let j = i + 1; j < particles.length; j++) {
      if (particles[i].type !== particles[j].type) continue;
      const dx = particles[i].x - particles[j].x;
      const dy = particles[i].y - particles[j].y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 120) {
        bgCtx.strokeStyle = particles[i].type === 'C'
          ? `rgba(106,159,106,${0.03 * (1 - dist/120)})`
          : `rgba(159,68,68,${0.02 * (1 - dist/120)})`;
        bgCtx.beginPath();
        bgCtx.moveTo(particles[i].x, particles[i].y);
        bgCtx.lineTo(particles[j].x, particles[j].y);
        bgCtx.stroke();
      }
    }
  }

  requestAnimationFrame(animBg);
}
animBg();

// === SCROLL REVEAL ===
const phases = document.querySelectorAll('.phase');
const phaseObserver = new IntersectionObserver((entries) => {
  entries.forEach(e => {
    if (e.isIntersecting) {
      e.target.classList.add('visible');
      const phaseNum = e.target.dataset.phase;

      // Trigger thought reveals for phase 3
      if (phaseNum === '3') {
        e.target.querySelectorAll('.thought').forEach((t, i) => {
          setTimeout(() => t.classList.add('show'), 200 + i * 300);
        });
      }

      // Animate matches for phase 4
      if (phaseNum === '4') {
        document.querySelectorAll('.match').forEach((m, mIdx) => {
          const hist = JSON.parse(m.dataset.hist);
          const lScore = parseInt(m.dataset.leftScore);
          const rScore = parseInt(m.dataset.rightScore);
          const maxS = parseInt(m.dataset.maxScore);
          const idx = parseInt(m.dataset.idx);

          // Animate rounds appearing
          const roundsEl = document.getElementById(`rounds-${idx}`);
          hist.forEach((h, rIdx) => {
            setTimeout(() => {
              const span = document.createElement('span');
              span.className = h[0] === 'C' ? 'c' : 'd';
              span.textContent = h[0];
              roundsEl.appendChild(span);

              const span2 = document.createElement('span');
              span2.className = h[1] === 'C' ? 'c' : 'd';
              span2.textContent = h[1];
              roundsEl.appendChild(span2);

              roundsEl.appendChild(document.createTextNode(' '));
            }, mIdx * 800 + rIdx * 60);
          });

          // Animate score bars
          setTimeout(() => {
            document.getElementById(`score-l-${idx}`).style.width = `${(lScore/maxS)*100}%`;
            document.getElementById(`score-r-${idx}`).style.width = `${(rScore/maxS)*100}%`;
            document.getElementById(`pts-l-${idx}`).textContent = lScore;
            document.getElementById(`pts-r-${idx}`).textContent = rScore;
          }, mIdx * 800 + 2500);
        });
      }

      // Animate leaderboard for phase 5
      if (phaseNum === '5') {
        sorted.forEach(([name, score], i) => {
          setTimeout(() => {
            document.getElementById(`leader-${i}`).classList.add('show');
            document.getElementById(`lb-bar-${i}`).style.width = `${(score/maxTotal)*100}%`;
            document.getElementById(`lb-score-${i}`).textContent = score;
          }, i * 500);
        });
      }

      // Draw calligram for phase 6
      if (phaseNum === '6') {
        setTimeout(drawCalligram, 300);
      }
    }
  });
}, { threshold: 0.15 });

phases.forEach(p => phaseObserver.observe(p));
</script>
</body>
</html>
